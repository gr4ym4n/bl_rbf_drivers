__NUXT_JSONP__("/tutorials/introduction", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G){return {data:[{document:{slug:"introduction",description:t,title:u,menuTitle:u,category:"Tutorials",position:101,fullscreen:true,toc:[{id:v,depth:h,text:w},{id:x,depth:h,text:y},{id:z,depth:h,text:A},{id:B,depth:h,text:f}],body:{type:"root",children:[{type:b,tag:i,props:{id:v},children:[{type:b,tag:j,props:{ariaHidden:k,href:"#what-is-rbf-drivers",tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:w}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"Fundamentally "},{type:b,tag:r,props:{},children:[{type:a,value:f}]},{type:a,value:" lets you animate any number of "},{type:b,tag:c,props:{},children:[{type:a,value:"output"}]},{type:a,value:" values based on any number of "},{type:b,tag:c,props:{},children:[{type:a,value:"input"}]},{type:a,value:" values. We do this by defining "},{type:b,tag:c,props:{},children:[{type:a,value:C}]},{type:a,value:". Defining a pose is simply telling "},{type:b,tag:r,props:{},children:[{type:a,value:f}]},{type:a,value:" that when "},{type:b,tag:c,props:{},children:[{type:a,value:"these"}]},{type:a,value:" input values are like "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:", I want "},{type:b,tag:c,props:{},children:[{type:a,value:"those"}]},{type:a,value:" output values to be like "},{type:b,tag:c,props:{},children:[{type:a,value:E}]},{type:a,value:". "},{type:b,tag:r,props:{},children:[{type:a,value:f}]},{type:a,value:" does all the heavy lifting to make it happen. In contrast to setting up constraints and Blender's native drivers you dont need to define "},{type:b,tag:c,props:{},children:[{type:a,value:"how"}]},{type:a,value:" something happens, just "},{type:b,tag:c,props:{},children:[{type:a,value:"what"}]},{type:a,value:" happens."}]},{type:a,value:d},{type:b,tag:i,props:{id:x},children:[{type:b,tag:j,props:{ariaHidden:k,href:"#what-is-the-difference",tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:y}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"To understand RBF drivers, it's helpful to first take a look at Blender's native drivers so that we can see how RBF drivers are different, and what makes them so powerful."}]},{type:a,value:d},{type:b,tag:i,props:{id:z},children:[{type:b,tag:j,props:{ariaHidden:k,href:"#blender-drivers",tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:A}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"On a basic level, a driver allows you to control the value of "},{type:b,tag:c,props:{},children:[{type:a,value:"one"}]},{type:a,value:" property (the "},{type:b,tag:c,props:{},children:[{type:a,value:g}]},{type:a,value:" property) using the value of one or more other properties (the "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" properties). This makes them somewhat similar to some of Blender's constraints, but whereas constraints set up predefined relationships between properties, drivers offer much more flexibility in defining how the "},{type:b,tag:c,props:{},children:[{type:a,value:g}]},{type:a,value:" property is affected by the "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" properties."}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"Let's look at a simple use-case to illustrate how Blender's native drivers can be used to fix a common problem in character rigging. The animation below shows a basic arm rig that doesn't deform the mesh very well during flexion of the forearm: the elbow doesn't hold its volume, the mesh breaks down on the inside of the elbow, and we don't see the contraction of the biceps."}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"There are a myriad of ways to fix these problems, but for our purposes we're going to stick with adding shape keys to the character mesh. We'll create shape keys for the elbow, inner arm and bicep, and set up drivers to drive their values based on the rotation of the forearm."}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"So far so good, but we'd like to take things a bit further and have the forearm and bicep deform properly during forearm pronation as well as flexion. We can create shape keys for those too, but this is where things start to get very tricky because somehow we're going to need to mix the values of "},{type:b,tag:c,props:{},children:[{type:a,value:F}]},{type:a,value:" shape keys together based on "},{type:b,tag:c,props:{},children:[{type:a,value:F}]},{type:a,value:" forearm rotation values. We could achieve this by using multiple drivers, helper bones or some nifty math, but it's going to be painful to set up and very unpleasant to work with further down the line."}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"What we want is a quick and simple way to set up a relationship between multiple "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" properties and multiple "},{type:b,tag:c,props:{},children:[{type:a,value:g}]},{type:a,value:" properties. We can do this with RBF drivers."}]},{type:a,value:d},{type:b,tag:i,props:{id:B},children:[{type:b,tag:j,props:{ariaHidden:k,href:"#rbf-drivers",tabIndex:l},children:[{type:b,tag:m,props:{className:[n,o]},children:[]}]},{type:a,value:f}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"Much like Blender's native drivers, with RBF drivers you select what properties you want to act as "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:G},{type:b,tag:c,props:{},children:[{type:a,value:s}]},{type:a,value:" in RBF drivers) but unlike Blender's drivers, you're not limited to a single "},{type:b,tag:c,props:{},children:[{type:a,value:g}]},{type:a,value:" property (known as a "},{type:b,tag:c,props:{},children:[{type:a,value:q}]},{type:a,value:" in RBF drivers), and you don't need to define a mathematical relationship between those "},{type:b,tag:c,props:{},children:[{type:a,value:s}]},{type:a,value:" and "},{type:b,tag:c,props:{},children:[{type:a,value:q}]}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"and what you  you want to act as "},{type:b,tag:c,props:{},children:[{type:a,value:g}]},{type:a,value:G},{type:b,tag:c,props:{},children:[{type:a,value:q}]},{type:a,value:"). But instead of defining a fixed"}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"You then simply need to define "},{type:b,tag:c,props:{},children:[{type:a,value:C}]},{type:a,value:", which tell the\r\nRBF driver that when the "},{type:b,tag:c,props:{},children:[{type:a,value:s}]},{type:a,value:" are like "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:", the "},{type:b,tag:c,props:{},children:[{type:a,value:q}]},{type:a,value:" should be like "},{type:b,tag:c,props:{},children:[{type:a,value:E}]},{type:a,value:"."}]},{type:a,value:d},{type:b,tag:e,props:{},children:[{type:a,value:"In our example, we just need to pose the forearm, set the shape key values so that"}]}]},dir:"\u002Fen\u002Ftutorials",path:"\u002Fen\u002Ftutorials\u002Fintroduction",extension:".md",createdAt:"2022-05-13T17:15:31.848Z",updatedAt:"2022-05-13T17:15:31.849Z",to:"\u002Ftutorials\u002Fintroduction"},prev:{title:t,path:"\u002Fen\u002Findex",to:"\u002F"},next:{title:"Installation",path:"\u002Fen\u002Ftutorials\u002Finstallation",to:"\u002Ftutorials\u002Finstallation"}}],fetch:{},mutations:[]}}("text","element","em","\n","p","RBF Drivers","driven",2,"h2","a","true",-1,"span","icon","icon-link","driving","outputs","strong","inputs","","Introduction","what-is-rbf-drivers","What is RBF Drivers?","what-is-the-difference","What is the difference","blender-drivers","Blender Drivers","rbf-drivers","poses","this","that","multiple"," properties (known as ")));